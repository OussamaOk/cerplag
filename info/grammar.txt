<program> -> <moduleDeclarations> <otherModules> <driverModule> <otherModules>
<moduleDeclarations> -> <moduleDeclaration> <moduleDeclarations> | e
<otherModules> -> <otherModule> <otherModules> | e
<otherModule> -> <otherModuleHead> <moduleBody>
<driverModule> -> <driverModuleHead> <moduleBody>
<moduleBody> -> START <stmts> END
<stmts> -> <stmt> <stmts> | e

<moduleDeclaration> -> DECLARE MODULE ID SEMICOL
<driverModuleHead> -> DEF DRIVER PROGRAM ENDDEF
<otherModuleHead> -> DEF MODULE ID ENDDEF TAKES INPUT SQBO <iParamList> SQBC SEMICOL <oParamStmt>
<oParamStmt> -> RETURNS SQBO <oParamList> SQBC SEMICOL | e
<oParamList> -> <oParam> <oParamList2>
<oParamList2> -> COMMA <oParam> <oParamList2> | e
<oParam> -> ID COLON <basicType>
<iParamList> -> <iParam> <iParamList2>
<iParamList2> -> COMMA <iParam> <iParamList2> | e
<iParam> -> ID COLON <type>

<basicType> -> INTEGER | REAL | BOOLEAN
<type> -> <basicType> | ARRAY SQBO <range> SQBC OF <basicType>
<range> -> NUM RANGEOP NUM
<varRange> -> <var> RANGEOP <var>
<index> -> NUM | ID
<var> -> ID <whichID>
<whichID> -> SQBO <index> SQBC | e
<aliteral> -> <var> | NUM | RNUM
<bliteral> -> <var> | TRUE | FALSE
<literal> -> <aliteral> | TRUE | FALSE
<const> -> NUM | RNUM | TRUE | FALSE

<stmt> -> <inputStmt> | <outputStmt> | <assignStmt> | <fCallStmt> | <declareStmt> | <condStmt> | <forStmt> | <whileStmt>
<inputStmt> -> GET_VALUE BO <var> BC SEMICOL
<outputStmt> -> PRINT BO <literal> BC SEMICOL
<assignStmt> -> <var> ASSIGNOP <expr> SEMICOL
<fCallStmt> -> <retCapture> USE MODULE ID WITH PARAMETERS <idList> SEMICOL
<idList> -> <id> <idList2>
<idList2> -> COMMA ID <idList2> | e
<declareStmt> -> DECLARE <idList> COLON <type> SEMICOL
<condStmt> -> SWITCH BO ID BC START <caseStmts> <defaultCase> END
<caseStmts> -> <caseStmt> <caseStmts>
<caseStmt> -> CASE <const> COLON <stmts> BREAK SEMICOL
<defaultCase> -> DEFAULT COLON <stmts> BREAK SEMICOL | e
<forStmt> -> FOR BO ID IN <varRange> BC START <stmts> END
<whileStmt> -> WHILE BO <boolExpr> BC START <stmts> END

<expr> -> <andExpr> <expr2>
<expr2> -> OR <andExpr> <expr2> | e
<andExpr> -> <relExpr> <andExpr2>
<andExpr2> -> AND <relExpr> <andExpr2> | e
<relExpr> -> <addExpr> <relExpr2>
<relExpr2> -> <relOp> <addExpr> <relExpr2> | e
<addExpr> -> <multExpr> <addExpr2>
<addExpr2> -> <pmOp> <multExpr> <addExpr2> | e
<multExpr> -> <unExpr> <multExpr2>
<multExpr2> -> <mdOp> <unExpr> <multExpr2> | e
<unExpr> -> <pmOp> <basicExpr> | <basicExpr>
<basicExpr> -> <var> | BO <expr> BC

<pmOp> -> PLUS | MINUS
<relOp> -> LT | LE | GT | GE | EQ | NE
<mdOp> -> MUL | DIV
